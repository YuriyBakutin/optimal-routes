# Описание данных и алгоритмов

В этой папке находятся данные, определяющие состояние приложения.

Реактивная их часть находится в модуле **store**, реализованном с помощью библиотеки [Pinia](Pinia), которая на данный момент (пока не вышел Vuex 5) является лучшим инструментом управления состоянием для Vue 3 + TypeScript.

Часть данных, реактивность которых не нужна, хранится в модуле **nonReactive**

## Основные объекты структуры данных

Информация, описывающая топологию связей соединений между странами и их стоимости, берётся из файла [call-paths.json](../../data/call-paths.json) и преобразуется в двумерный список (**paths**), первым ключом которого служит код страны, из которой идёт звонок (**src**), а вторым — код страны в которую идёт звонок (**des**). По этим двум ключам хранится объект (**path**) — массив связей (**link**), по которым может быть осуществлено соединение. Элемент этого массива представляет из себя пару полей — название компании, обеспечивающей соединение, и стоимость её услуги. Массив связей упорядочен по стоимости услуги по возрастанию. Двумерный список **paths** не является непосредственным источником данных для UI. Поэтому он не реактивен и хранится в модуле **nonReactive**

Массивы маршрутов (**routes**) хранятся в двумерном списке с теми же ключами (src) и (des). Каждый из них последовательно пополняется в результате работы механизма поиска текущего оптимального маршрута из оставшихся вариантов, запускаемого при выборе пользователем пары (src) и (des). Двумерный список массивов маршрутов непосредственно привязан к UI и хранится в **store**.

Кроме рассмотренных основных объектов, требуются вспомогательные объекты данных обеспечивающие работу алгоритма поиска оптимального маршрута из оставшихся. О них пойдёт речь после описании самого алгоритма.

## Алгоритм поиска оптимального маршрута из оставшихся

Для поиска оптимального маршрута между двумя узлами взвешенного графа используется алгоритм Дейкстры. На входе он должен получить взвешенный граф — набор вершин и связей между ними, представленных "весом" (в нашем случае это стоимость соединения). Возвращает он маршрут с наименьшим суммарным весом связей в виде последовательности узлов.

Для нашей задачи мы не можем использовать алгоритм Дейкстры непосредственно, так как структура данных у нас более сложная, чем та, с которой работает данный алгоритм. Нам нужно преобразование **paths** в граф, который может быть обработан алгоритмом поиска оптимального маршрута. На первом шаге, очевидно, нужно взять самые дешёвые связи между узлами, и на этой основе создать граф для алгоритма Дейкстры. После того, как мы получим первый маршрут, нам нужно его исключить из дальнейшего поиска.

Создание графа для первого оптимального маршрута однозначно. Дальше однозначности уже нет. Нам нужно выбрать несколько вариантов графа — несколько кандидатов на получение следующего оптимального маршрута. Алгоритм этого выбора следующий. Нужно взять за основу найденный оптимальный маршрут, и получить графы — кандидаты путём обхода связей найденного маршрута с переходом на каждой связи на следующее по стоимости соединение. Если такого соединения нет, связь разрывается.

![](../../.idea/Image%202.svg)

После подбора кандидатов, для каждого из них ищется оптимальный маршрут. Если для какого-то графа-кандидата маршрут не может быть найден, этот граф удаляется из списка кандидатов. После того как маршруты кандидатов найдены, из них выбирается оптимальный. Граф, соответствующий этому маршруту, удаляется из списка кандидатов. На основе найденного маршрута формируется список новых дополнительных кандидатов, и присоединяется к старому. Далее, поиск итерационно повторяется, пока не наступит состояния, когда алгоритм Дейкстры не сможет выдать маршрут ни для одного кандидата.

## Структура данных, обеспечивающих работу алгоритма поиска

Описанный алгоритм предполагает хранение графов-кандидатов. Для части этих графов могут быть уже найдены оптимальные маршруты. Есть смысл хранить два списка кандидатов — список кандидатов, для которых маршруты ещё не найдены, и список тех, для кого оптимальные маршруты уже найдены. При том, в последнем списке вместе с кандидатами следует хранить и найденные маршруты. То есть, когда для графа определяется оптимальный маршрут, он переносится в список кандидатов с маршрутами. После того, как список кандидатов без маршрутов будет полностью исчерпан, ищется оптимальный из найденных маршрутов в списке кандидатов с маршрутами. Кандидат с оптимальным маршрутом удаляется из списка, а на основе найденного маршрута формируется новый список кандидатов без маршрутов.

Для того, чтобы сформировать такой список, нужно хранить индексы используемых соединений в объекте кандидата. Таким образом, в кандидате сохраняются не веса связей, а индексы соединений, содержащих веса. При поиске оптимального маршрута функция-адаптер на основе индексов кандидата формирует граф с весами, с которым уже работает алгоритм Дейкстры.

При формировании списка новых кандидатов на основе найденного маршрута возможно получение дубликатов — совпадения некоторых новых кандидатов, с теми, которые уже были обработаны ранее, и находящимися в списке кандидатов с маршрутами. Поэтому при формировании нового списка кандидатов без маршрутов необходима дополнительная проверка и исключение дубликатов. Для её упрощения каждый кандидат в списке имеет уникальный строковый ключ, однозначно определяемый параметрами кандидата.

Работу с кандидатами реализована с помощью класса ManagingRouteSearch, хранящего списки кандидатов и имеющего методы для реализации пошагового поиска оптимальных путей.
