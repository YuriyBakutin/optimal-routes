# Задача 3

Перед вами макет фильтрации маршрутов звонков (логика маршрутизации выдумана и имеет малое сходство с реальностью). Необходимо реализовать клиент по фильтрации и сортировки этих маршрутов.

![Layout](./.idea/layout.png)

В решении должны быть:

- Форма с двумя выпадающими списками стран и чекбоксами для фильтрации
- Отсортированные маршруты по цене от меньшей к большей
- Пагинация списка

В [файле](./data/call-paths.json) представлены mock данные с сервера.

```js
  const request = {
    'data': {
      company: {
        'waterTel': [ // Название телеком компании
          {
            'src': 'kz', // Звонящая сторона (Caller)
            'des': 'usa', // Принимающая сторона (Callee)
            'price': 9 // Цена
          },
        ],
      },
      country: { // Расшифровка стран
        'ru': 'Россия',
        'kz': 'Казахстан',
        'de': 'Германия',
        'us': 'США'
      }
    }
  }
```

## Принцип работы

Предоставлять пользователю все возможные маршруты (в маршруте указываются страны, через которые проходит звонок, и операторы, обслуживающие соединение) от "Звонящий стороны" до "Принимающей стороны", отсортированные по цене (в одном маршруте страны не могут повторяться). Фильтры маршрутов в виде чекбоксов "Прямое соединение" - без промежуточных стран, "Один дополнительный узел" - с одной промежуточной страной и т.д.

## Условия

- Используйте Vue
- Работоспособность в актуальной версии Google Chrome

## Решение

### Алгоритм и технология расчётов

На простом приложенном небольшом наборе mock данных, можно сразу получить все маршруты, а потом их сортировать, фильтровать и т.п. Но такое решение практически не масштабируется, поскольку с увеличением количества стран и возможных вариантов соединений между ними, число маршрутов будет нарастать лавинообразно, и время ожидания их получения и сортировки быстро выйдет за рамки не только приемлемого времени ожидания для пользователя, но и за рамки разумных возможностей вычислительной техники.

Поэтому в решении реализован итерационный алгоритм, на каждом шаге которого ищется оптимальный маршрут из всех возможных, затем этот маршрут включается последним в упорядоченный список маршрутов, отображаемых для пользователя и исключается из возможных вариантов для следующего поиска. Затем ищется следующий оптимальный маршрут, и так далее, пока не будут перебраны все маршруты. Возможно этот момент и не наступит за всё время работы программы, но это и не требуется, так как пользователю данные выводятся небольшими порциями, которые он перебирает последовательно, начиная с начала списка.

Вероятность того, что пользователь, листая страницы, "догонит" поисковый процесс, невелика. И даже в этом случае ему просто придётся немного подождать, пока поиск заполнит очередную страницу и на ней появится актуальная информация вместо спиннера.

Структура данных и алгоритм последовательного поиска оптимальных маршрутов описаны [здесь](./src/data/readme.md).

Для того, чтобы процесс построения списка маршрутов не тормозил UI, он вынесен в **WebWorker**. Для оптимизации скорости поиска лучше было бы написать его код на языке C и подключить в WebWorker с помощью WebAssembly, но поскольку это задание — тестовое, и указанная технология в условии не фигурируют, да к тому же у меня нет практического опыта работы с ней, эта оптимизация осталась нереализованной.

### Сборка и запуск

Для запуска приложения нужно для начала установить зависимости

```bash
pnpm i
```

Затем выполнить сборку и запуск dev-сервера

```bash
pnpm run dev
```

После этого приложение можно открыть по адресу [http://localhost:3000/](http://localhost:3000/)

Некоторые особенности сборки описаны [здесь](./src/components/README.md).
